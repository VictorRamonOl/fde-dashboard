# app.py
# -- coding utf-8 --

import io
import re
from pathlib import Path
from typing import List, Optional, Tuple

import pandas as pd
import streamlit as st


# =========================================================
# PAGE CONFIG
# =========================================================
st.set_page_config(
    page_title=FNDE  Dashboard Executivo,
    page_icon=üìä,
    layout=wide,
    initial_sidebar_state=expanded,
)

DATA_DIR_DEFAULT = Path(data)


# =========================================================
# FORMATTERS
# =========================================================
def _to_float(v) - float
    try
        return float(v)
    except Exception
        return 0.0


def br_int(v) - str
    Inteiro pt-BR 4.500.000
    n = int(round(_to_float(v), 0))
    return f{n,}.replace(,, .)


def brl_int(v) - str
    Moeda pt-BR sem centavos R$ 4.500.000
    return fR$ {br_int(v)}


def df_to_excel_bytes(sheets List[Tuple[str, pd.DataFrame]]) - bytes
    Gera um XLSX em mem√≥ria com v√°rias abas.
    out = io.BytesIO()
    with pd.ExcelWriter(out, engine=openpyxl) as writer
        for name, df in sheets
            safe = re.sub(r[[]], _, name)[31]  # limite do Excel
            df.to_excel(writer, sheet_name=safe, index=False)
    out.seek(0)
    return out.read()


# =========================================================
# MUNICIPIO NORMALIZATION
# (teu fnde.py salva MAUES e BOA_VISTA_DO_RAMOS)
# =========================================================
MUN_KEYS_ORDER = [MAUES, BOA_VISTA_DO_RAMOS]
MUN_LABEL = {
    MAUES Mau√©s,
    BOA_VISTA_DO_RAMOS Boa Vista do Ramos,
}


def normalize_municipio_key(raw str) - str
    s = (raw or ).strip().upper()
    s = s.replace(√Å, A).replace(√É, A).replace(√Ç, A)
    s = s.replace(√â, E).replace(√ä, E)
    s = s.replace(√ç, I)
    s = s.replace(√ì, O).replace(√î, O).replace(√ï, O)
    s = s.replace(√ö, U)
    s = s.replace(-, _).replace( , _)

    if BOA in s and RAM in s
        return BOA_VISTA_DO_RAMOS
    if MAU in s
        return MAUES
    # fallback devolve o que vier
    return s


# =========================================================
# FILE DISCOVERY
# =========================================================
def find_years_available(data_dir Path) - List[int]
    if not data_dir.exists()
        return []
    years = set()
    for p in data_dir.glob(liberacoes_tidy_AM_.csv)
        # liberacoes_tidy_AM_2025_MAUES.csv
        # liberacoes_tidy_AM_2025_MAUES_BVR.csv
        parts = p.name.split(_)
        if len(parts) = 4
            try
                years.add(int(parts[3]))
            except Exception
                pass
    return sorted(list(years))


def preferred_consolidated_file(data_dir Path, year int) - Optional[Path]
    # preferir consolidado MAUES_BVR
    cand = data_dir  fliberacoes_tidy_AM_{year}_MAUES_BVR.csv
    if cand.exists()
        return cand
    # fallback qualquer tidy do ano
    any_files = list(data_dir.glob(fliberacoes_tidy_AM_{year}_.csv))
    return any_files[0] if any_files else None


# =========================================================
# LOADING
# =========================================================
@st.cache_data(show_spinner=False)
def load_tidy_year(data_dir Path, year int) - pd.DataFrame
    p = preferred_consolidated_file(data_dir, year)
    if p is None or not p.exists()
        return pd.DataFrame()

    df = pd.read_csv(p, dtype=str, encoding=utf-8-sig)
    if df.empty
        return df

    # Valor_num - float
    if Valor_num in df.columns
        df[Valor_num] = pd.to_numeric(df[Valor_num], errors=coerce).fillna(0.0)
    else
        if Valor_str in df.columns
            s = (
                df[Valor_str]
                .astype(str)
                .str.replace(., , regex=False)
                .str.replace(,, ., regex=False)
            )
            df[Valor_num] = pd.to_numeric(s, errors=coerce).fillna(0.0)
        else
            df[Valor_num] = 0.0

    # Ano
    if Ano in df.columns
        df[Ano] = pd.to_numeric(df[Ano], errors=coerce).fillna(year).astype(int)
    else
        df[Ano] = year

    # Municipio
    if Municipio not in df.columns
        df[Municipio] = 
    df[Municipio_raw] = df[Municipio].astype(str)
    df[MunicipioKey] = df[Municipio_raw].apply(normalize_municipio_key)
    df[MunicipioLabel] = df[MunicipioKey].map(MUN_LABEL).fillna(df[Municipio_raw])

    # ProgramaGrupo  Programa  RazaoSocial
    for col in [ProgramaGrupo, Programa, RazaoSocial, CNPJ, CNPJ_formatado, OB, Parcela]
        if col not in df.columns
            df[col] = 

    # DataPgto e M√™s
    # teu csv j√° tem Mes (YYYY-MM). Vamos for√ßar.
    if Mes in df.columns
        df[Mes] = df[Mes].astype(str)
        # normalizar poss√≠veis strings estranhas
        df[Mes] = df[Mes].str.slice(0, 7)
    else
        df[Mes] = 

    # Se Mes veio vazio, tenta derivar de DataPgto
    if DataPgto in df.columns
        df[DataPgto] = pd.to_datetime(df[DataPgto], errors=coerce)
        need = df[Mes].isna()  (df[Mes].astype(str).str.strip() == )  (df[Mes].astype(str) == NaT)
        if need.any()
            df.loc[need, Mes] = df.loc[need, DataPgto].dt.strftime(%Y-%m)
    else
        df[DataPgto] = pd.NaT

    # Mes_dt para ordenar (primeiro dia do m√™s)
    df[Mes_dt] = pd.to_datetime(df[Mes] + -01, errors=coerce)

    # limpeza leve
    df[ProgramaGrupo] = df[ProgramaGrupo].fillna().astype(str)
    df[Programa] = df[Programa].fillna().astype(str)
    df[RazaoSocial] = df[RazaoSocial].fillna().astype(str)

    return df


# =========================================================
# FILTER ENGINE
# =========================================================
def apply_filters(
    df pd.DataFrame,
    year int,
    mes_ref str,
    mun_keys List[str],
    grupos List[str],
    programas List[str],
    escolas List[str],
    busca_escola str,
) - pd.DataFrame
    if df.empty
        return df

    out = df[df[Ano] == year].copy()

    if mes_ref and mes_ref != Todos
        out = out[out[Mes] == mes_ref]

    if mun_keys
        out = out[out[MunicipioKey].isin(mun_keys)]

    if grupos
        out = out[out[ProgramaGrupo].isin(grupos)]

    if programas
        out = out[out[Programa].isin(programas)]

    if escolas
        out = out[out[RazaoSocial].isin(escolas)]

    if busca_escola.strip()
        pat = busca_escola.strip().lower()
        out = out[out[RazaoSocial].str.lower().str.contains(pat, na=False)]

    return out


# =========================================================
# SAFE MULTISELECT WITH SELECT ALL  CLEAR
# (sem quebrar session_state)
# =========================================================
def multiselect_with_buttons(
    label str,
    options List[str],
    key str,
    default Optional[List[str]] = None,
    help_text Optional[str] = None,
    height_hint str = compact,
) - List[str]
    
    Regras para n√£o dar erro
    - Inicializa st.session_state[key] ANTES do widget
    - Bot√µes usam on_click (callback), ent√£o na rerun j√° vem setado antes do widget instanciar
    
    if default is None
        default = []

    if key not in st.session_state
        st.session_state[key] = list(default)

    def _select_all()
        st.session_state[key] = list(options)

    def _clear()
        st.session_state[key] = []

    cols = st.columns([1, 1], gap=small)
    with cols[0]
        st.button(Selecionar todos, on_click=_select_all, key=f{key}__btn_all, use_container_width=True)
    with cols[1]
        st.button(Limpar, on_click=_clear, key=f{key}__btn_clear, use_container_width=True)

    # widget
    return st.multiselect(
        label,
        options=options,
        key=key,
        help=help_text,
    )


# =========================================================
# KPI + CHARTS
# =========================================================
def kpis_for_mun(df pd.DataFrame, mun_key str) - Tuple[float, int, int]
    d = df[df[MunicipioKey] == mun_key]
    total = float(d[Valor_num].sum()) if not d.empty else 0.0
    pagamentos = int(len(d)) if not d.empty else 0
    entidades = int(d[CNPJ].nunique()) if not d.empty else 0
    return total, pagamentos, entidades


def render_kpis_side_by_side(df_filt pd.DataFrame)
    c1, c2 = st.columns(2, gap=large)

    left_key = MAUES
    right_key = BOA_VISTA_DO_RAMOS

    with c1
        st.subheader(füü¶ {MUN_LABEL.get(left_key, left_key)})
        total, pags, ents = kpis_for_mun(df_filt, left_key)
        k1, k2, k3 = st.columns(3)
        k1.metric(Total Recebido, brl_int(total))
        k2.metric(Pagamentos (linhas), br_int(pags))
        k3.metric(Entidades (CNPJ), br_int(ents))

    with c2
        st.subheader(füü© {MUN_LABEL.get(right_key, right_key)})
        total, pags, ents = kpis_for_mun(df_filt, right_key)
        k1, k2, k3 = st.columns(3)
        k1.metric(Total Recebido, brl_int(total))
        k2.metric(Pagamentos (linhas), br_int(pags))
        k3.metric(Entidades (CNPJ), br_int(ents))


def chart_evolucao_mensal_por_municipio(df_filt pd.DataFrame)
    if df_filt.empty
        st.info(Sem dados para os filtros selecionados.)
        return

    evo = (
        df_filt.groupby([Mes_dt, Mes, MunicipioLabel], as_index=False)
        .agg(Total=(Valor_num, sum))
        .sort_values([Mes_dt, MunicipioLabel])
    )

    pivot = evo.pivot_table(index=Mes, columns=MunicipioLabel, values=Total, aggfunc=sum).fillna(0.0)
    # ordem cronol√≥gica
    pivot.index = pd.to_datetime(pivot.index + -01, errors=coerce)
    pivot = pivot.sort_index()
    pivot.index = pivot.index.strftime(%Y-%m)

    st.line_chart(pivot)


def chart_evolucao_mensal_todos_programas(df_filt pd.DataFrame)
    Mesmo gr√°fico acima, mas com um t√≠tulo refor√ßando 'todos os programas'.
    chart_evolucao_mensal_por_municipio(df_filt)


def chart_evolucao_por_grupo(df_filt pd.DataFrame, grupos_ordem Optional[List[str]] = None)
    
    Um gr√°fico (linha) por Grupo (ProgramaGrupo).
    Linhas por munic√≠pio.
    
    if df_filt.empty
        st.info(Sem dados para os filtros selecionados.)
        return

    base = df_filt.copy()
    base[ProgramaGrupo] = base[ProgramaGrupo].fillna().astype(str).str.strip()
    base = base[base[ProgramaGrupo] != ]
    if base.empty
        st.info(Sem ProgramaGrupo preenchido para os filtros selecionados.)
        return

    grupos = sorted(base[ProgramaGrupo].unique().tolist())
    if grupos_ordem
        # mant√©m os que existirem nessa ordem, depois o resto
        ordered = [g for g in grupos_ordem if g in grupos]
        rest = [g for g in grupos if g not in ordered]
        grupos = ordered + rest

    for g in grupos
        st.markdown(f### {g})
        dg = base[base[ProgramaGrupo] == g]

        evo = (
            dg.groupby([Mes_dt, Mes, MunicipioLabel], as_index=False)
            .agg(Total=(Valor_num, sum))
            .sort_values([Mes_dt, MunicipioLabel])
        )

        pivot = evo.pivot_table(index=Mes, columns=MunicipioLabel, values=Total, aggfunc=sum).fillna(0.0)
        pivot.index = pd.to_datetime(pivot.index + -01, errors=coerce)
        pivot = pivot.sort_index()
        pivot.index = pivot.index.strftime(%Y-%m)

        st.line_chart(pivot)


def chart_distribuicao_por_grupo_barras(df_filt pd.DataFrame)
    
    Mant√©m como voc√™ pediu embaixo, barras por munic√≠pio
    
    if df_filt.empty
        st.info(Sem dados para os filtros selecionados.)
        return

    base = df_filt.copy()
    base[ProgramaGrupo] = base[ProgramaGrupo].fillna().astype(str).str.strip()
    base = base[base[ProgramaGrupo] != ]
    if base.empty
        st.info(Sem ProgramaGrupo preenchido para os filtros selecionados.)
        return

    agg = (
        base.groupby([MunicipioKey, MunicipioLabel, ProgramaGrupo], as_index=False)
        .agg(Total=(Valor_num, sum))
    )

    # Mau√©s √† esquerda, BVR √† direita
    c1, c2 = st.columns(2, gap=large)
    for col, mun_key in [(c1, MAUES), (c2, BOA_VISTA_DO_RAMOS)]
        with col
            mlabel = MUN_LABEL.get(mun_key, mun_key)
            st.markdown(f### {mlabel})
            dm = agg[agg[MunicipioKey] == mun_key].sort_values(Total, ascending=False)
            if dm.empty
                st.caption(Sem dados para este munic√≠pio com os filtros atuais.)
                continue

            top = dm.head(12).copy()
            bar = top.set_index(ProgramaGrupo)[[Total]]
            st.bar_chart(bar)

            tbl = top.copy()
            tbl[Total (R$)] = tbl[Total].apply(brl_int)
            st.dataframe(tbl[[ProgramaGrupo, Total (R$)]], use_container_width=True, hide_index=True)


def top_programas(df_filt pd.DataFrame, top_n int = 30) - pd.DataFrame
    if df_filt.empty
        return pd.DataFrame()
    g = (
        df_filt.groupby([Ano, Mes, MunicipioLabel, Programa], as_index=False)
        .agg(Total=(Valor_num, sum), Pagamentos=(Valor_num, count))
        .sort_values([Ano, Mes, MunicipioLabel, Total], ascending=[True, True, True, False])
    )
    g[Total (R$)] = g[Total].apply(brl_int)
    g[Pagamentos] = g[Pagamentos].apply(br_int)
    return g.head(top_n)


def top_escolas(df_filt pd.DataFrame, top_n int = 30) - pd.DataFrame
    if df_filt.empty
        return pd.DataFrame()
    g = (
        df_filt.groupby([Ano, Mes, MunicipioLabel, RazaoSocial, CNPJ_formatado], as_index=False)
        .agg(Total=(Valor_num, sum), Pagamentos=(Valor_num, count))
        .sort_values([Ano, Mes, MunicipioLabel, Total], ascending=[True, True, True, False])
    )
    g[Total (R$)] = g[Total].apply(brl_int)
    g[Pagamentos] = g[Pagamentos].apply(br_int)
    return g.head(top_n)


def comparativos_municipios_por_programa(df_filt pd.DataFrame, top_n int = 15) - pd.DataFrame
    if df_filt.empty
        return pd.DataFrame()
    g = (
        df_filt.groupby([Programa, MunicipioLabel], as_index=False)
        .agg(Total=(Valor_num, sum))
    )
    # pega os top programas (somando ambos munic√≠pios)
    tot = g.groupby(Programa, as_index=False).agg(TotalGeral=(Total, sum)).sort_values(TotalGeral, ascending=False)
    keep = tot.head(top_n)[Programa].tolist()
    g = g[g[Programa].isin(keep)]
    pivot = g.pivot_table(index=Programa, columns=MunicipioLabel, values=Total, aggfunc=sum).fillna(0.0)
    pivot = pivot.reset_index()
    # ordenar pelo total
    pivot[TotalGeral] = pivot.drop(columns=[Programa]).sum(axis=1)
    pivot = pivot.sort_values(TotalGeral, ascending=False).drop(columns=[TotalGeral])
    # formatar
    for c in pivot.columns
        if c != Programa
            pivot[c] = pivot[c].apply(brl_int)
    return pivot


# =========================================================
# REGULARIZA√á√ÉO  ALERTAS
# (Nesta fase l√™ um CSV se existir em data)
# Sugest√£o voc√™ gerar em fnde.py um arquivo dataregularizacao_{ano}.csv
# com colunas MunicipioKey, RazaoSocial, CNPJ_formatado, Alerta
# =========================================================
def load_regularizacao(data_dir Path, year int) - pd.DataFrame
    # tenta por ano
    p1 = data_dir  fregularizacao_{year}.csv
    if p1.exists()
        df = pd.read_csv(p1, dtype=str, encoding=utf-8-sig)
        return df

    # fallback gen√©rico
    p2 = data_dir  regularizacao.csv
    if p2.exists()
        df = pd.read_csv(p2, dtype=str, encoding=utf-8-sig)
        return df

    return pd.DataFrame()


def render_regularizacao(df_reg pd.DataFrame)
    st.subheader(üö® Regulariza√ß√£o  Alertas)

    if df_reg.empty
        st.info(
            Ainda n√£o existe arquivo de regulariza√ß√£o.nn
            üëâ Pr√≥ximo passo no `fnde.py`, gerar `dataregularizacao_YYYY.csv` capturando as mensagens do site 
            (Dados cadastrais  Presta√ß√£o de contas) e marcando pend√™ncias.nn
            Quando esse arquivo existir, esta aba vai preencher automaticamente.
        )
        return

    # normalizar municipio
    if MunicipioKey not in df_reg.columns
        # tenta inferir por nome
        for cand in [Municipio, Munic√≠pio]
            if cand in df_reg.columns
                df_reg[MunicipioKey] = df_reg[cand].astype(str).apply(normalize_municipio_key)
                break
        if MunicipioKey not in df_reg.columns
            df_reg[MunicipioKey] = 

    df_reg[MunicipioLabel] = df_reg[MunicipioKey].map(MUN_LABEL).fillna(df_reg.get(Municipio, ))

    # dividir Mau√©s  BVR
    c1, c2 = st.columns(2, gap=large)
    for col, mun_key in [(c1, MAUES), (c2, BOA_VISTA_DO_RAMOS)]
        with col
            st.markdown(f### {MUN_LABEL.get(mun_key, mun_key)})
            d = df_reg[df_reg[MunicipioKey] == mun_key].copy()
            st.metric(Qtde com alerta, br_int(len(d)))
            # escolher colunas √∫teis
            cols = [c for c in [RazaoSocial, CNPJ_formatado, Alerta, Observacao, Programa] if c in d.columns]
            if not cols
                cols = d.columns.tolist()
            st.dataframe(d[cols], use_container_width=True, hide_index=True)


# =========================================================
# SIDEBAR DATA DIR + RELOAD
# =========================================================
with st.sidebar
    st.header(Dados)

    project_dir = st.text_input(
        Pasta do projeto (ou data),
        value=str(Path(.).resolve()),
        help=Aponte para a pasta onde existe o subdiret√≥rio 'data' com os CSVs gerados pelo fnde.py.,
        key=project_dir,
    )

    proj = Path(project_dir)
    data_dir = proj  data
    if not data_dir.exists()
        data_dir = DATA_DIR_DEFAULT

    st.caption(fPasta efetiva de leitura {data_dir})

    with st.expander(Atualiza√ß√£o  Recarregar, expanded=False)
        st.caption(Se voc√™ acabou de gerar CSVs novos, clique para recarregar o cache.)
        if st.button(Recarregar dados (limpar cache), use_container_width=True)
            st.cache_data.clear()
            st.success(Cache limpo. Recarregado na pr√≥xima execu√ß√£o.)

# =========================================================
# LOAD YEAR OPTIONS
# =========================================================
years = find_years_available(data_dir)
if not years
    st.error(
        N√£o encontrei CSVs `liberacoes_tidy_AM_.csv` na pasta de dados.nn
        füëâ Verifique se existe `{data_dir}` e se o `fnde.py` gerou os arquivos.
    )
    st.stop()

# =========================================================
# MAIN TITLE
# =========================================================
st.title(üìä FNDE  Dashboard Executivo)
st.caption(Baseado exclusivamente nos CSVs gerados pelo `fnde.py` (pasta data). Valores sem centavos (R$).)


# =========================================================
# SIDEBAR FILTERS
# =========================================================
with st.sidebar
    st.header(Filtros)
    with st.expander(AbrirFechar filtros, expanded=True)
        year = st.selectbox(Ano, years, index=len(years) - 1, key=year_sel)

        df_year = load_tidy_year(data_dir, year)
        if df_year.empty
            st.warning(fSem dados carregados para {year}.)
        else
            st.success(fArquivos TIDY encontrados para {year} OK)

        # m√™s refer√™ncia (YYYY-MM)
        mes_opts = [Todos]
        if not df_year.empty
            mes_vals = df_year[Mes].dropna().astype(str)
            mes_vals = sorted([m for m in mes_vals.unique().tolist() if re.match(r^d{4}-d{2}$, m)])
            mes_opts = [Todos] + mes_vals

        mes_ref = st.selectbox(M√™s (refer√™ncia), mes_opts, index=0, key=mes_ref)

        # munic√≠pios (por key)
        mun_opts = [k for k in MUN_KEYS_ORDER]
        if not df_year.empty
            present = df_year[MunicipioKey].dropna().astype(str).unique().tolist()
            mun_opts = [k for k in MUN_KEYS_ORDER if k in present] or mun_opts

        # multiselect com bot√µes
        mun_sel_keys = multiselect_with_buttons(
            Munic√≠pio,
            options=[MUN_LABEL.get(k, k) for k in mun_opts],
            key=mun_sel_labels,
            default=[MUN_LABEL.get(k, k) for k in mun_opts],
            help_text=Mau√©s sempre aparece primeiro. Voc√™ pode filtrar 1 ou ambos.,
        )
        # converter labels - keys
        label_to_key = {MUN_LABEL.get(k, k) k for k in mun_opts}
        mun_sel = [label_to_key.get(x, x) for x in mun_sel_keys]

        # grupos e programas
        grupo_opts = []
        prog_opts = []
        escola_opts = []

        if not df_year.empty
            grupo_opts = sorted([g for g in df_year[ProgramaGrupo].dropna().astype(str).unique().tolist() if g.strip()])
            prog_opts = sorted([p for p in df_year[Programa].dropna().astype(str).unique().tolist() if p.strip()])
            escola_opts = sorted([e for e in df_year[RazaoSocial].dropna().astype(str).unique().tolist() if e.strip()])

        st.markdown(---)
        grupos_sel = multiselect_with_buttons(
            Grupo (ProgramaGrupo),
            options=grupo_opts,
            key=grupo_sel,
            default=[],
            help_text=Deixe vazio para n√£o restringir.,
        )

        programas_sel = multiselect_with_buttons(
            Programa,
            options=prog_opts,
            key=programa_sel,
            default=[],
            help_text=Deixe vazio para n√£o restringir.,
        )

        st.markdown(---)
        busca_escola = st.text_input(
            Buscar escolaentidade (texto),
            value=,
            help=Filtra por parte do nome (Raz√£o Social).,
            key=busca_escola,
        )

        escolas_sel = multiselect_with_buttons(
            EscolaEntidade (Raz√£o Social),
            options=escola_opts,
            key=escola_sel,
            default=[],
            help_text=Opcional. Se selecionar aqui, restringe para essas escolas.,
        )

        st.caption(Dica se algum gr√°fico parecer zerado, normalmente √© filtro (GrupoProgramaEscola).)


# =========================================================
# APPLY FILTERS
# =========================================================
df_year = load_tidy_year(data_dir, year)
df_filt = apply_filters(
    df=df_year,
    year=year,
    mes_ref=mes_ref,
    mun_keys=mun_sel,
    grupos=grupos_sel,
    programas=programas_sel,
    escolas=escolas_sel,
    busca_escola=busca_escola,
)

if df_year.empty
    st.warning(Sem dados carregados para o ano selecionado.)
elif df_filt.empty
    st.warning(Sem dados para os filtros selecionados. Ajuste os filtros na lateral.)


# =========================================================
# TABS
# =========================================================
tab1, tab2, tab3, tab4, tab5 = st.tabs([
    Vis√£o Geral,
    Top Programas  Escolas,
    Comparativos,
    Regulariza√ß√£o  Alertas,
    Tabela Detalhada  Downloads,
])


# =========================================================
# TAB 1 ‚Äî VIS√ÉO GERAL
# =========================================================
with tab1
    st.subheader(fVis√£o Geral ‚Äî {year}  M√™s (ref.) {mes_ref})

    render_kpis_side_by_side(df_filt)
    st.divider()

    st.markdown(## Evolu√ß√£o mensal (por munic√≠pio) ‚Äî todos os programas)
    chart_evolucao_mensal_todos_programas(df_filt)

    st.divider()
    st.markdown(## Evolu√ß√£o mensal por Grupo (ProgramaGrupo))
    st.caption(Um gr√°fico por Grupo. Linhas por munic√≠pio. (Mensal, sem dias.))
    chart_evolucao_por_grupo(df_filt)

    st.divider()
    st.markdown(## Distribui√ß√£o por Grupo (R$))
    chart_distribuicao_por_grupo_barras(df_filt)


# =========================================================
# TAB 2 ‚Äî TOP PROGRAMAS  ESCOLAS
# =========================================================
with tab2
    st.subheader(Top Programas  Escolas)
    st.caption(Mostra Ano e M√™s de refer√™ncia (Mes) para leitura r√°pida.)

    c1, c2 = st.columns(2, gap=large)

    with c1
        st.markdown(### Top Programas)
        tp = top_programas(df_filt, top_n=40)
        if tp.empty
            st.info(Sem dados para Top Programas com os filtros atuais.)
        else
            st.dataframe(tp[[Ano, Mes, MunicipioLabel, Programa, Total (R$), Pagamentos]], use_container_width=True, hide_index=True)

    with c2
        st.markdown(### Top Escolas  Entidades)
        te = top_escolas(df_filt, top_n=40)
        if te.empty
            st.info(Sem dados para Top Escolas com os filtros atuais.)
        else
            st.dataframe(te[[Ano, Mes, MunicipioLabel, RazaoSocial, CNPJ_formatado, Total (R$), Pagamentos]], use_container_width=True, hide_index=True)


# =========================================================
# TAB 3 ‚Äî COMPARATIVOS
# =========================================================
with tab3
    st.subheader(Comparativos)
    st.caption(Compara√ß√£o Mau√©s x Boa Vista do Ramos (mesma base filtrada).)

    comp = comparativos_municipios_por_programa(df_filt, top_n=20)
    if comp.empty
        st.info(Sem dados para Comparativos com os filtros atuais.)
    else
        st.markdown(### Top Programas ‚Äî compara√ß√£o por munic√≠pio (Total R$))
        st.dataframe(comp, use_container_width=True, hide_index=True)


# =========================================================
# TAB 4 ‚Äî REGULARIZA√á√ÉO  ALERTAS
# =========================================================
with tab4
    df_reg = load_regularizacao(data_dir, year)
    render_regularizacao(df_reg)


# =========================================================
# TAB 5 ‚Äî TABELA DETALHADA  DOWNLOADS
# =========================================================
with tab5
    st.subheader(Tabela Detalhada  Downloads)
    if df_filt.empty
        st.info(Sem dados para os filtros selecionados.)
    else
        d = df_filt.copy()

        # exibir tabela detalhada
        d[Valor (R$)] = d[Valor_num].apply(brl_int)
        # colunas principais
        cols = [
            Ano, Mes, MunicipioLabel,
            ProgramaGrupo, Programa, Parcela, OB,
            RazaoSocial, CNPJ_formatado,
            Valor (R$),
        ]
        # data se tiver
        if DataPgto in d.columns
            cols.insert(2, DataPgto)

        # ordenar por m√™s
        if Mes_dt in d.columns
            d = d.sort_values([Ano, Mes_dt, MunicipioLabel, ProgramaGrupo, Programa, RazaoSocial], ascending=True)

        st.dataframe(d[cols], use_container_width=True, hide_index=True)

        st.divider()
        st.markdown(## Downloads (Excel) ‚Äî leitura r√°pida mensal)

        # 1) Consolidado mensal por munic√≠pio
        m1 = (
            d.groupby([Ano, Mes, MunicipioLabel], as_index=False)
            .agg(Total=(Valor_num, sum), Pagamentos=(Valor_num, count), Entidades=(CNPJ, nunique))
        )
        m1[Total (R$)] = m1[Total].apply(brl_int)
        m1[Pagamentos] = m1[Pagamentos].apply(br_int)
        m1[Entidades] = m1[Entidades].apply(br_int)
        m1 = m1[[Ano, Mes, MunicipioLabel, Total (R$), Pagamentos, Entidades]].sort_values([Ano, Mes, MunicipioLabel])

        # 2) Mensal por Grupo
        m2 = (
            d.groupby([Ano, Mes, MunicipioLabel, ProgramaGrupo], as_index=False)
            .agg(Total=(Valor_num, sum))
        )
        m2[Total (R$)] = m2[Total].apply(brl_int)
        m2 = m2[[Ano, Mes, MunicipioLabel, ProgramaGrupo, Total (R$)]].sort_values([Ano, Mes, MunicipioLabel, Total (R$)], ascending=[True, True, True, False])

        # 3) Mensal por Programa
        m3 = (
            d.groupby([Ano, Mes, MunicipioLabel, Programa], as_index=False)
            .agg(Total=(Valor_num, sum))
        )
        m3[Total (R$)] = m3[Total].apply(brl_int)
        m3 = m3[[Ano, Mes, MunicipioLabel, Programa, Total (R$)]].sort_values([Ano, Mes, MunicipioLabel, Total (R$)], ascending=[True, True, True, False])

        # 4) Escolas mensal (r√°pido)
        m4 = (
            d.groupby([Ano, Mes, MunicipioLabel, RazaoSocial, CNPJ_formatado, Programa], as_index=False)
            .agg(Total=(Valor_num, sum))
        )
        m4[Total (R$)] = m4[Total].apply(brl_int)
        m4 = m4[[Ano, Mes, MunicipioLabel, RazaoSocial, CNPJ_formatado, Programa, Total (R$)]].sort_values(
            [Ano, Mes, MunicipioLabel, Total (R$)], ascending=[True, True, True, False]
        )

        xls = df_to_excel_bytes([
            (Consolidado_Mensal_Municipio, m1),
            (Mensal_por_Grupo, m2),
            (Mensal_por_Programa, m3),
            (Mensal_Escolas_Programa, m4),
            (Detalhado_Filtrado, d.drop(columns=[Valor_num], errors=ignore).copy()),
        ])

        st.download_button(
            üì• Baixar Excel (consolidado mensal + detalhado),
            data=xls,
            file_name=ffnde_dashboard_{year}_mes_{mes_ref.replace('-', '') if mes_ref != 'Todos' else 'todos'}.xlsx,
            mime=applicationvnd.openxmlformats-officedocument.spreadsheetml.sheet,
            use_container_width=True,
        )


st.caption(
    Notas leitura por m√™s (sem centavos). Mau√©s sempre √† esquerda e BVR √† direita. 
    Se aparecer 'Sem dados', revise filtros (principalmente GrupoProgramaEscola).
)
